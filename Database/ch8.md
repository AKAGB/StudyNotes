# Chapter 8 — 关系数据库设计
## 8.1 好的关系设计的特点
1. **有损分解**，将关系模式分解后，如果分解后的模式存在没有主码的情况，则是有损分解。
2. **无损分解**：不是有损分解的分解时无损的，这是我们期望的。

## 8.2 原子域和第一范式
1. **原子域**：如果一个域的元素被认为是不可分的单元，
2. **第一范式（1NF）**：一个关系模式R的所有属性都是原子的，则是第一范式。

## 8.3 使用函数依赖进行分解
### 8.3.1 码和函数依赖
1. R的子集K是r(R)的超码的条件是：在关系r(R)的任意合法实例中，对于r的实例中的所有元组对$t_1$和$t_2$总满足，若$t_1 \not= t_2$，则$t_1[K] \not= t_2[K]$。
2. 令$\alpha \subset R且\beta \subset R$，给定一个r(R)的一个实例，我们说这个实例满足**函数依赖**$\alpha \to \beta$的条件是：对实例中的所有元组对$t_1和t_2$，若$t_1[\alpha]=t_2[\alpha]$，则$t_1[\beta]=t_2[\beta]$。
3. 如果对在r(R)的每一个合法实例中都满足依赖$\alpha \to \beta$，则我们说该函数依赖在模式r(R)上成立。
4. 对于超码K，显然有$K \to R$。
5. 如果$\beta \subset \alpha$，则形如$\alpha \to \beta$的函数依赖是**平凡的**。
6. $F^+$表示$F$集合的闭包，也就是能够从给定集合$F$推导出的所有函数依赖的集合。

### 8.3.2 Boyce-Codd范式
1. **BCNF**消除了所有基于函数依赖能够发现的冗余
2. 具有函数依赖集F的关系模式R术语BCNF的条件是，对于$F^+$中所有形如$\alpha \to \beta$的函数依赖，下面至少有一项成立：

    - $\alpha \to \beta$是平凡的函数依赖。
    - $\alpha$是模式R的一个超码。

3. 设R为不属于BCNF的一个模式，则存在至少一个非平凡的函数依赖$\alpha \to \beta$，其中$\alpha$不是R的超码，则模式可分解为：

    - $(\alpha \cup \beta)$
    - $(R-(\beta - \alpha ))$

### 8.3.3 BCNF和保持依赖
1. 有时为了满足一致性约束，我们不想让某些函数依赖被用于分解模式，尽管这个依赖不满足BCNF的条件。
2. 需要一种**保持依赖的**范式，它比BCNF稍弱，引入**第三范式**。

### 8.3.4 第三范式
具有函数依赖集F的关系模式属于**第三范式（3NF）**的条件是，对于$F^+$中的所有形如$\alpha \to \beta$的函数依赖，以下至少一项成立：

- $\alpha \to \beta$是一个平凡的函数依赖。
- $\alpha$是R的一个超码。
- $\beta - \alpha$中的每个属性A都包含于R的一个候选码中，不要求每个属性都属于同一个候选码。

## 8.4 函数依赖理论
### 8.4.1 函数依赖集的闭包
1. 给定一个关系模式r(R)，如果r(R)的每一个满足F的实例也满足f，则称R上的函数依赖f被r上的函数依赖集F**逻辑蕴含**。
2. **Armstrong**公理：

    - **自反律**：若$\alpha$为一属性集且$\beta \subseteq \alpha$，则$\alpha \to \beta$成立。
    - **增补律**：若$\alpha \to \beta$成立且$\gamma$为一属性集，则$\gamma\alpha \to \gamma\beta$。
    - **传递律**：若$\alpha \to \beta$何$\beta \to \gamma$成立，则$\alpha \to \gamma$

3. 常用规则：

    - **合并律**：若$\alpha \to \beta$和$\alpha \to \gamma$成立，则$\alpha \to \beta\gamma$成立。
    - **分解律**：若$\alpha \to \beta\gamma$成立，则$\alpha \to \beta$和$\alpha \to \gamma$成立。
    - **伪传递律**：若$\alpha \to \beta$和$\gamma\beta \to \delta$成立，则$\alpha\gamma \to \delta$成立。

4. 书上图8-7给出了一个计算$F^+$的算法。

### 8.4.2 属性集的闭包
1. 如果$\alpha \to B$，我们称属性B被$\alpha$**函数确定**。
2. 将函数依赖集F下被$\alpha$函数确定的所有属性的集合称为F下$\alpha$的闭包。
3. **（必掌握）**书上图8-8给出计算$\alpha^+$的算法。
4. 为了判断$\alpha$是否为超码，先计算$\alpha^+$，检查是否包含R中的所有属性。
5. 通过检查是否$\beta \subseteq \alpha^+$，检查$\alpha \to \beta$是否成立。

### 8.4.3 正则覆盖
1. 如果去除函数依赖中的一个属性不改变该函数依赖集的闭包，则称该属性是**无关的**。
2. 检验一个属性A的无关性的方法：

    - 若$A \in \beta$，则考虑集合

        <center>$F' = (F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - A)\}$</center>
        
        检查$\alpha \to A$是否能够由$F'$推出。为此，计算$F'下\alpha^+$，如果其中包含A则说明A是无关的。
        
    - 若$A \in \alpha$，令$\gamma = \alpha - \{A\}$，检查$\gamma \to \beta$是否能被F推出，因此计算$F下\gamma^+$，检查是否包含所有的$\beta$的属性。

3. F的**正则覆盖**$F_c$是一个依赖集，使得F罗技蕴含$F_c$中的所有依赖，并且$F_c$逻辑蕴含F中的所有依赖，并满足以下条件：

    - $F_c$中的任何函数依赖都不包含无关属性。
    - $F_c$中函数依赖的左半部分都是唯一的。

4. **（必掌握）**书上图8-9给出计算正则覆盖的算法。
