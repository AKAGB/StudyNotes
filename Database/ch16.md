# Chapter16 — 恢复系统
## 16.1 故障分类
系统的故障分为以下几种：

- **事务故障**。有两种错误可能造成事务执行失败：

    - **逻辑错误**：事务由于某些内部条件而无法继续正常执行。
    - **系统错误**：系统进入不良状态（如死锁），导致事务无法正常执行。
    
- **系统崩溃**：硬件故障，或者是数据库软件或操作系统漏洞，导致易失性存储器内容的丢失，使得事务处理停止。而非易失性存储器内容完好无损。

- **磁盘故障**：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。

## 16.2 存储器
存储器分为以下3类：
    - 易失性存储器
    - 非易失性存储器
    - 稳定存储器

### 16.2.1 稳定存储器的实现
1. 在内存和磁盘存储器间进行块传送有以下几种可能：

    - **成功完成**
    - **部分失败**
    - **完全失败**

### 16.2.2 数据访问
1. 位于磁盘上的块称为**物理块**，临时位于主存的块称为**缓冲块**，内存中用于临时存放块的区域称为**磁盘缓冲区**。
2. 磁盘和主存之间的块移动是由下面两个操作引发的：

    - input(B)：传送物理块B至主存。
    - output(B)：传送缓冲块B至磁盘。

3. 事务$T_i$通过其在工作区和系统缓冲区之间传送数据，用下面两个操作传送数据：

    - read(X)将数据项X的值赋予$x_i$。操作过程如下：
        
        - 若X所在的块$B_x$不在主存中，则发指令执行input($B_x$)。
        - 将缓冲块中X的值赋给$x_i$。

    - write(X)将局部变量$x_i$的值赋予缓冲块中的数据项X，执行如下：

        - 若X所在块$B_x$不在主存中，则发指令执行input($B_x$)。
        - 将$x_i$的值赋予缓冲块$B_x$中的X。

4. 如果数据库系统发指令执行output(B)，则称数据库系统对缓冲块B进行**强制输出**。

## 16.3 恢复与原子性
### 16.3.1 日志记录
1. **日志**：是**日志记录**的序列，它记录数据库中的所有更新活动。
2. **更新日志记录**：是日志记录的一种，它具有以下几个字段：

    - **事务标识**：是执行**write**操作的事务的唯一标识。
    - **数据项标识**：是所写数据项的唯一标识。
    - **旧值**：是数据项的写前值。
    - **新值**：是数据项的写后值。

3. 将一个更新日志记录表示为$<T_i, X_j, V_1, V_2>$。
4. 其他的一些日志记录类型：

    - $<T_i start>$。事务$T_i$开始。
    - $<T_i commit>$。事务$T_i$提交。
    - $<T_i abort>$。事务$T_i$终止。

### 16.3.2 数据库修改
1. 事务在进行数据项修改中所采取的步骤：

    - 事务在主存中自己私有的部分执行某些计算。
    - 事务修改主存的磁盘缓冲区中包含该数据项的数据块。
    - 数据库系统执行**output**操作，将数据块写到磁盘中。

2. **延迟修改**：一个事务直到它提交时都没有修改数据库。
3. **立即修改**：数据库修改在事务仍然活跃时发生。
4. 恢复算法必须考虑的因素：

    - 有可能一个事务已经提交了，虽然它所做的某些数据库修改还仅仅存在于主存中。
    - 有可能处于活动状态的一个事务已经修改了数据库，而作为后来发生的故障的后果，这个事务需要终止。

5. 两个操作：

    - **undo**：使用一个日志记录，将该日志记录中指明的数据项设置为旧值。
    - **redo**：使用一个日志记录，将该日志中指明的数据项设置为新值。

### 16.3.3 并发控制和恢复
恢复算法通常要求如果一个数据项被一个事务修改了，那么在该事务提交或终止前不允许其他事务修改该数据项。

### 16.3.4 事务提交
1. commit日志记录：该事务的最后一个日志记录。
2. 当一个事务的commit日志记录输出到稳定存储器后，我们就说这个事务**提交**了。
3. 包含commit日志记录的块的输出时单个原子动作，它导致一个事务的提交。

### 16.3.5 使用日志用来重做和撤销事务
1. redo($T_i$)将事务$T_i$更新过的所有数据项的值都设置为新值。通过redo来执行更新的顺序是非常重要的。
2. undo($T_i$)将事务$T_i$更新过的所有数据项的值都恢复为旧值。

    - undo不仅将数据项恢复为旧值，而且作为撤销过程的一部分，还写日志记录来记下更新（特殊的**redo-only**日志记录）。
    - 对于事务$T_i$的undo操作完成后，它写一个$<T_i abort>$日志记录，表明撤销完成了。

3. 在日志的每一个事务最终或者有一条commit记录，或者有一条abort记录。
4. 系统崩溃后，查阅日志已确定哪些redo，哪些undo：

    - 如果日志包括$<T_i start>$记录，但不包括abort或commit记录，则需要对事务$T_i$进行undo。
    - 如果日志包括$<T_i start>$记录，也包含abort或commit记录，则需要对事务$T_i$进行redo。

### 16.3.6 检查点
1. **检查点**：

    - 在执行检察点操作的过程中不允许执行任何更新。
    - 在执行检察点的过程中将所有更新过的缓冲区都输出到磁盘。

2. 检察点的执行过程如下：

    - 将当前位于主存的所有日志记录输出到稳定存储器。
    - 将所有修改的缓冲块输出到磁盘。
    - 将一个日志记录<**checkpoint** L>输出到稳定存储器，其中L是执行检察点时正活跃的事务的列表。

## 16.4 恢复算法
### 16.4.1 事务回滚
事务$T_i$的回滚如下执行：

1. 从后往前扫描日志，对于所发现的$T_i$的每一个形如$<T_i, X_j, V_1, V_2>$的日志记录：
    - 值$V_1$被写到数据项$X_j$中，并且
    - 往日志中写一个特殊的只读日志记录$<T_i, X_j, V_1>$，被称为补偿日志记录。

2. 一旦发现了$<T_i, start>$日志记录，就停止从后往前扫描，并往日志中写一个$<T_i, abort>$日志记录。

### 16.4.2 系统崩溃后的恢复
恢复动作分两阶段进行：

1. **重做（redo）阶段**：系统通过从最后一个检察点开始正向地扫描日志来重放所有事务的更新。扫描日志的具体步骤如下：

    - 将要回滚的事务的列表undo-list初始设定为checkpoint记录中的L。
    - 一旦遇到形为$<T_i, X_j, V_1, V_2>$的正常日志记录或形为$<T_1, X_j, V_1>$的redo-only日志记录，就redo这个操作，也就是将$V_2$写给$X_j$。
    - 一旦发现形为$<T_i, start>$的日志记录，就把$T_i$加入undo-list中。
    - 一旦发现$<T_i, abort>$或$<T_i, commit>$记录，就把$T_i$从undo-list中去掉。

     在redo阶段末尾，undo-list包括没有提交或没有完成回滚的事务。
     
2. **撤销（undo）阶段**：回滚undo-list中的所有事务，从尾端开始反向扫描日志来进行回滚：

    - 一旦发现属于undo-list中事务的日志记录，就执行undo操作。
    - 当系统发现undo-list中事务$T_i$的$<T_i, start>$日志记录，它就往日志中写一条$<T_i, abort>$记录，并把$T_i$从undo-list中去掉。
    - 一旦undo-list变为空表，则撤销阶段结束。

     当撤销阶段结束后，就可以重新开始正常的事务处理了。
