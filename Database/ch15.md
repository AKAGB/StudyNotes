# Chapter15 — 并发控制
## 15.1 基于锁的协议
### 15.1.1 锁
1. 给数据加锁的方式考虑以下两种：

    - **共享的**：如果事务$T_i$获得了数据项Q上的共享型锁（记为S），则$T_i$可读但不可写数据Q。
    - **排他的**：如果事务$T_i$获得了数据项Q上的排他型锁（记为X），则$T_i$既可读又可写数据Q。

2. 每个事务都要根据自己对数据Q的操作类型**申请**适当的锁。事务只有在并发控制管理器**授予**所需锁后才能继续其操作。
3. **相容函数**：令A与B代表任意的锁类型，假设事务$T_i$请求对数据项Q加A类型锁，而事务$T_j(T_j \not= T_i)$在当前数据项Q上拥有B类型锁，如果事务$T_i$可以立即获得数据项Q上的锁，则说A类型锁和B类型锁是**相容的**。相容函数可以通过相容性矩阵来表示。
4. 一个事务通过执行**lock-S(Q)**指令来申请数据项Q上的共享锁，**lock-X(Q)**来申请排他锁，**unlock(Q)**指令来释放数据项Q上的锁。
5. 在其他事务的不相容锁释放前，事务只能**等待（wait）**。
6. **封锁**：事务执行完才释放锁。
7. **死锁**：多个事务都在相互等待其他事务释放锁，而自己又持有其他事务所需的锁，可能导致无论哪一个事务都无法正常执行的结果，称为死锁。当死锁发生时，系统必须回滚一些事务，一旦事务回滚，它所拥有的锁就会被释放。
8. **封锁协议**：规定事务何时对数据项们进行加锁、解锁。

### 15.1.2 锁的授予
1. 在某些调度中可能导致某一个事务始终无法得到执行，这种现象是**饿死**。
2. 避免**饿死**：当事务$T_i$申请对数据项Q加M型锁时，并发控制管理器授权加锁的条件是：

    - 不存在在数据项Q上持有与M型锁冲突的锁的其他事务。
    - 不存在等待对数据项Q加锁且先于$T_i$申请加锁的事务。

### 15.1.3 两阶段封锁协议
1. **两阶段封锁协议**：要求每个事务分两个阶段提出加锁和解锁申请：

    - **增长阶段**：事务可以获得锁，但不能释放锁。
    - **缩减阶段**：事务可以释放锁，但不能获得新锁。

2. **封锁点**：事务的封锁点是该事务获得其最后加锁的位置。多个事务可以根据他们的封锁点进行排序，这个顺序就是事务的一个可串行化顺序。
3. 两阶段封锁并不保证不会发生死锁，且级连回滚可能发生。
4. 级连回滚可以通过修改为**严格两阶段封锁协议**加以避免：要求事务持有的所有排他锁必须在事务提交后方可释放。
5. **强两阶段封锁协议**：要求事务提交前不得释放任何锁。在该条件下，事务可以按照其提交的顺序串行化。
6. 对基本的两阶段封锁协议加以修改，允许**锁转换**，即提供将共享锁**升级**为排他锁，将排他锁**降级**为共享锁的机制。

### 15.1.4 封锁的实现
1. **锁管理器**可以使实现为一个过程，他从事务接受信息并反馈信息。锁管理器针对锁请求消息授予锁消息，或者要求事务回滚的消息（发生死锁时）。
2. **锁表**：锁管理器为目前已加锁的每个数据项维护一个链表，使用锁表（一个以数据项名称为索引的散列表）来查找连表中的数据项。

### 15.1.5 基于图的协议
1. 要求所有数据项集合$\boldsymbol{D} = \{d_1, d_2, ..., d_n\}$满足偏序$\to$：如果$d_i \to d_j$，则任何既访问$d_i$又访问$d_j$的事务必须首先访问$d_j$，然后访问$d_j$。
2. 根据数据项的偏序关系构造的有向无环图，称为**数据库图**。
3. **树形协议**中，可用的加锁指令只有**lock-X**。每个事务$T_j$对一对数据项最多只能加一次锁，并且遵从：

    - $T_i$首次加锁可以对任何数据项进行。
    - 此后，$T_i$对数据项Q加锁的前提是$T_i$当前持有Q的父项上的锁。
    - 对数据项解锁可以随时进行。
    - 数据项被$T_i$加锁并解锁后，$T_i$不能再对该数据项加锁。

4. 所有满足树形协议的调度是冲突可串行化的。
5. 树形协议不仅保证冲突可串行性，而且保证不会产生死锁。

## 15.2 死锁处理
处理死锁主要有两种方法：
    - **死锁预防**：保证系统永远不会进入死锁状态。
    - **死锁检测**与**死锁恢复**：允许系统进入死锁状态，然后进行恢复。

### 15.2.1 死锁预防
1. 预防死锁有两种方法：
    
    - 通过对加锁请求排序或要求同时获得所有的锁来保证不会发生循环等待。
    - 每当有可能导致死锁，进行事务回滚。

2. 防止死锁的一种机制是对所有的数据项强加一个次序，同时要求事务只能按次序规定的顺序封锁数据项。
3. 防止死锁的第二种方法是使用抢占与事务回滚。
4. **抢占**：若事务$T_j$所申请的锁已被事务$T_i$持有，则授予$T_i$的锁可能通过回滚事务$T_i$被抢占，并将锁授予$T_j$。为控制抢占，我们给事务赋一个唯一的时间戳，系统仅用时间戳来决定事务应当等待还是回滚。
5. **wait-die**机制：当事务$T_i$申请的数据项当前被$T_j$占有，仅当$T_i$的时间戳小于$T_j$的时间戳（即，$T_i$比$T_j$老）时，允许$T_i$等待，否则$T_i$回滚。
6. **wound-wait**机制：与wait-die恰好相反，仅当年轻时等待。
7. **锁超时**：申请锁的事务最多等待一段给定时间。若在此期间未授予该事务锁，则称该事务超时，该事务自动回滚并重启。

### 15.2.2 死锁检测与恢复
1. **死锁检测**：死锁可以用**等待图**来精确描述。该图由$G=(V, E)$对组成，其中V时顶点集，E是边集。顶点集由事务组成，边是有序对$T_i \to T_j$，代表事务$T_i$在等待事务$T_j$释放所需的数据项。
2. 当且仅当图包含环时，系统存在死锁。
3. 何时激活检测算法取决于：

    - 死锁发生的频度。
    - 有多少事务将受到死锁的影响。
4. **恢复**：解除死锁最通常的做法是回滚一个或多个事务。采取的动作有三个：

    - **选择牺牲者**：应该使事务回滚的代价最小。
    - **回滚**：包括**彻底回滚**和**部分回滚**，部分回滚需要系统维护所有正在运行事务的额外状态。
    - **饿死**：在系统中，如果牺牲者主要基于代价因素，有可能同一事务总是被选为牺牲者，所以必须保证一个事务被选为牺牲者的次数有限。

## 15.3 多粒度
1. 我们需要一种允许系统定义多级**粒度**的机制，通过允许各种大小的数据项并定义数据粒度的层次结构，其中最小粒度的数据项嵌套在大粒度数据项中来实现，可以图像化地表示为树。
2. 当事务对一个节点加锁，或为共享锁或为排他锁，该事务也以同样类型的锁隐式地封锁这个节点的所有后代节点。
3. 判定一个事务是否能加锁：必须从树根到达目标节点进行遍历，如果发现此路径上某个节点的锁与要加的锁类型不相容，则事务必须延迟。
4. **意向锁**：如果给一个节点加上了意向锁，则意为着要在树的较低层进行显式加锁。所以要给一个节点显示加锁时，需要给所有祖先节点加上意向锁。
5. 意向锁又分为:
    - **共享型意向锁**（IS）：其较低层的节点加了显式的共享锁。
    - **排他型意向锁**（IX）：其较低层架了显式的排他锁或共享锁。
    - **共享排他型意向锁**（SIX）：以该节点为根的子树显式的家了共享锁，并且在树的更低层显式地加了排他锁。
6. **多粒度封锁协议**规定每个事务$T_i$要求按如下规则对数据项Q加锁：

    - 事务$T_i$必须遵从锁类型的相容函数。
    - $T_i$必须首先封锁树的根节点，并且可以加任意类型的锁。
    - 仅当$T_i$当前未对Q的父节点具有IX或IS锁时，$T_i$对节点Q可加S或IS锁。
    - 仅当$T_i$当前未对Q的父节点具有IX或SIX锁时，$T_i$对节点Q可加X、SIX或IX锁。
    - 仅当$T_i$未曾对任何节点解锁时，$T_i$可以对节点加锁（也就是说，$T_i$是两阶段的）。
    - 仅当$T_i$当前不持有Q的子节点的锁时，$T_i$可对节点Q解锁。

7. 多粒度协议要求加锁按*自顶向下*的顺序，而释放锁按*自底向上*的顺序。
